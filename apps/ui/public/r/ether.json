{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ether",
  "description": "An atmospheric animated background built with Three.js.",
  "type": "registry:example",
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/default/examples/ether.tsx",
      "content": "\"use client\"\\n\\nimport { useEffect, useRef } from \\\"react\\\"\\nimport * as THREE from \\\"three\\\"\\n\\nconst PRIMARY_COLOR = \\\"#4338ca\\\"\\nconst ACCENT_COLOR = \\\"#60a5fa\\\"\\nconst BASE_COLOR = \\\"#111827\\\"\\n\\nexport default function Ether() {\\n  const mountRef = useRef<HTMLDivElement | null>(null)\\n  const animationRef = useRef<number>()\\n\\n  useEffect(() => {\\n    const mount = mountRef.current\\n    if (!mount) return\\n\\n    const scene = new THREE.Scene()\\n    scene.background = null\\n\\n    const camera = new THREE.PerspectiveCamera(\\n      45,\\n      mount.clientWidth / mount.clientHeight,\\n      0.1,\\n      100\\n    )\\n    camera.position.set(0, 0, 6)\\n\\n    const renderer = new THREE.WebGLRenderer({\\n      antialias: true,\\n      alpha: true,\\n    })\\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.75))\\n    renderer.setSize(mount.clientWidth, mount.clientHeight, false)\\n    renderer.outputEncoding = THREE.sRGBEncoding\\n    mount.appendChild(renderer.domElement)\\n\\n    const geometry = new THREE.PlaneGeometry(8, 8, 120, 120)\\n    const material = new THREE.MeshStandardMaterial({\\n      color: PRIMARY_COLOR,\\n      emissive: ACCENT_COLOR,\\n      emissiveIntensity: 0.2,\\n      side: THREE.DoubleSide,\\n      wireframe: true,\\n      transparent: true,\\n      opacity: 0.45,\\n    })\\n\\n    const mesh = new THREE.Mesh(geometry, material)\\n    mesh.rotation.x = Math.PI / 6\\n    scene.add(mesh)\\n\\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8)\\n    const spotLight = new THREE.SpotLight(0x8b5cf6, 1.2, 25, Math.PI / 6, 0.7, 1.5)\\n    spotLight.position.set(6, 8, 6)\\n    const fillLight = new THREE.PointLight(0x22d3ee, 0.6, 30)\\n    fillLight.position.set(-6, -4, 6)\\n    scene.add(ambientLight, spotLight, fillLight)\\n\\n    const positions = geometry.attributes.position as THREE.BufferAttribute\\n    const basePositions = Float32Array.from(positions.array as Float32Array)\\n    const clock = new THREE.Clock()\\n\\n    const animate = () => {\\n      const elapsed = clock.getElapsedTime()\\n\\n      const arr = positions.array as Float32Array\\n      for (let i = 0; i < arr.length; i += 3) {\\n        const ox = basePositions[i]\\n        const oy = basePositions[i + 1]\\n        const oz = basePositions[i + 2]\\n\\n        const wave =\\n          Math.sin(elapsed * 0.8 + ox * 0.6 + oy * 0.4) * 0.25 +\\n          Math.cos(elapsed * 0.5 + ox * 0.3 - oy * 0.6) * 0.15\\n\\n        arr[i + 2] = oz + wave\\n      }\\n      positions.needsUpdate = true\\n\\n      mesh.rotation.z = Math.sin(elapsed * 0.12) * 0.2\\n      mesh.rotation.y = Math.cos(elapsed * 0.18) * 0.1\\n\\n      renderer.render(scene, camera)\\n      animationRef.current = requestAnimationFrame(animate)\\n    }\\n\\n    const handleResize = () => {\\n      if (!mount) return\\n      const { clientWidth, clientHeight } = mount\\n      camera.aspect = clientWidth / clientHeight\\n      camera.updateProjectionMatrix()\\n      renderer.setSize(clientWidth, clientHeight, false)\\n    }\\n\\n    animate()\\n    window.addEventListener(\\\"resize\\\", handleResize)\\n\\n    return () => {\\n      if (animationRef.current) {\\n        cancelAnimationFrame(animationRef.current)\\n      }\\n      window.removeEventListener(\\\"resize\\\", handleResize)\\n      mount.removeChild(renderer.domElement)\\n\\n      geometry.dispose()\\n      material.dispose()\\n      renderer.dispose()\\n    }\\n  }, [])\\n\\n  return (\\n    <div className=\\\"relative flex min-h-[420px] items-center justify-center overflow-hidden rounded-[2.5rem] border border-white/10 bg-[radial-gradient(circle_at_20%_20%,rgba(59,130,246,0.25),transparent_55%),radial-gradient(circle_at_80%_10%,rgba(167,139,250,0.25),transparent_55%),linear-gradient(180deg,#020617_0%,#0f172a_45%,#111827_100%)]\\\">\\n      <div ref={mountRef} className=\\\"absolute inset-0\\\" />\\n      <div className=\\\"pointer-events-none absolute inset-x-0 bottom-0 h-1/2 bg-gradient-to-t from-slate-950/95 via-slate-900/35 to-transparent\\\" />\\n      <div className=\\\"pointer-events-none absolute inset-0 bg-[radial-gradient(circle_at_center,rgba(96,165,250,0.08),transparent_55%)]\\\" />\\n      <div className=\\\"relative z-10 mx-auto max-w-xl text-center text-slate-100\\\">\\n        <span className=\\\"inline-flex items-center gap-2 rounded-full border border-white/15 bg-white/5 px-4 py-1 text-[10px] font-semibold uppercase tracking-[0.35em] text-slate-200/70 backdrop-blur-md\\\">\\n          Ether Field\\n        </span>\\n        <h2 className=\\\"mt-6 text-4xl font-semibold tracking-tight text-white\\\">\\n          Atmospheric depth for immersive canvases\\n        </h2>\\n        <p className=\\\"mt-4 text-base text-slate-300/85\\\">\\n          A reactive lattice powered by Three.js that creates a living, breathing\\n          gradient. Built for landing pages looking for subtle motion without\\n          overwhelming the content layered on top.\\n        </p>\\n      </div>\\n    </div>\\n  )\\n}\\n",
      "type": "registry:example"
    }
  ],
  "categories": [
    "backgrounds",
    "three",
    "animation"
  ]
}
